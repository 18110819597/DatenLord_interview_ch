module axi_stream_insert_header #(
        parameter DATA_WD = 32,
        parameter DATA_BYTE_WD = DATA_WD / 8,
        parameter BYTE_CNT_WD = $clog2(DATA_BYTE_WD)
) (
        input                           clk             ,
        input                           rst_n           ,
        // AXI Stream input original data   
        input                           valid_in        ,
        input   [DATA_WD-1 : 0]         data_in         ,
        input   [DATA_BYTE_WD-1 : 0]    keep_in         ,
        input                           last_in         ,
        output  reg                    ready_in        ,
        // AXI Stream output with header inserted   
        output                          valid_out       ,
        output [DATA_WD-1 : 0]          data_out        ,
        output [DATA_BYTE_WD-1 : 0]     keep_out        ,
        output                          last_out        ,
        input                           ready_out       ,
        // The header to be inserted to AXI Stream input
        input                           valid_insert    ,
        input [DATA_WD-1 : 0]           data_insert     ,
        input [DATA_BYTE_WD-1 : 0]      keep_insert     ,
        input [BYTE_CNT_WD-1 : 0]       byte_insert_cnt ,
        output  reg                        ready_insert
);
// Your code here


//reg define
reg 		[7:0]			                  head_regs	[DATA_WD - 1:0] ;
reg 		[7:0]			                  data_regs	[DATA_WD - 1:0] ;
reg         [7:0]                             data_reg [7:0]  ;
reg                                           ready_in_ff ;
reg                                           ready_in_ff2;   
reg     [DATA_WD-1 : 0]                       data_out_reg         ;
reg     [BYTE_CNT_WD - 1 : 0]                 cnt_1 ;    
reg     [DATA_WD - 1 : 0]                     data_in_ff    ;
wire    [$clog2(DATA_WD - 1) - 1 : 0]         valid_header_bit ;   //header 有效字节的起始位置
wire    [$clog2(DATA_WD - 1) - 1 : 0]         valid_data_bit    ;  //data 有效字节的结束位置
wire    [BYTE_CNT_WD-1 : 0]                   vld_head_byte ; 
wire    [BYTE_CNT_WD-1 : 0]                   vld_data_byte ; 


assign data_out = data_out_reg ;
assign valid_header_bit = 8 * byte_insert_cnt - 1;
assign vld_head_byte = byte_insert_cnt - 1 ;
assign vld_data_byte = DATA_BYTE_WD - cnt_1 ;

integer i;
always @(*) begin
    cnt_1 = 'd0 ;
    for (i = 0 ; i < DATA_BYTE_WD ; i = i+1) begin
        if (keep_in[i] == 1)
            cnt_1 = cnt_1 + keep_in[i];
    end
end





assign  valid_data_bit = cnt_1 * 8 ;

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        ready_in_ff <= 1'b0 ;
    else
        ready_in_ff <= ready_in ; 
end
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        ready_in_ff2 <= 1'b0 ;
    else
        ready_in_ff2 <= ready_in_ff ; 
end
always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        data_in_ff <= 'd0 ;
    else
        data_in_ff <= data_in ; 
end

/* always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        valid_header_bit <= 'd0 ;
    else if ()
        valid_header_bit <= 8 * byte_insert_cnt - 1 ;
    else
        valid_header_bit <= valid_header_bit ; 
end */


always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        ready_insert <= 1'b0 ;
    else if (ready_in)
        ready_insert <= 1'b0 ;
    else if (ready_out && valid_in && valid_insert)
        ready_insert <= 1'b1 ;
    else
        ready_insert <= ready_insert ; 
end

always @(posedge clk or negedge rst_n) begin
    if (!rst_n)
        ready_in <= 1'b0 ;
    else if (last_in)
        ready_in <= 1'b0 ;
    else if (ready_out && valid_in && valid_insert) 
        ready_in <= 1'b1 ;
    else
        ready_in <= ready_in ;
end


genvar j;
generate for (j = 0 ; j < DATA_BYTE_WD ; j = j+1) begin
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
            data_regs[j] <= 'd0;
        else if (valid_insert && ready_insert && j >= 0 && j < byte_insert_cnt)
            data_regs[j] <= data_insert[DATA_WD - 1 - (DATA_BYTE_WD - byte_insert_cnt + j)*8 -: 8] ;
        else if (valid_insert && ready_insert && j >= byte_insert_cnt && j < DATA_BYTE_WD)
            data_regs[j] <= data_in[DATA_WD - 1 - (DATA_BYTE_WD - byte_insert_cnt + j)*8 -: 8] ;
        else if (valid_in && ready_in && last_in != 1'b1 && j >= byte_insert_cnt && j < DATA_BYTE_WD)
            data_regs[j] <= data_in[DATA_WD -1 - (j - byte_insert_cnt)*8 -: 8] ;
        else if (valid_in && ready_in && last_in != 1'b1 && j >= 0 && j < byte_insert_cnt)
            data_regs[j] <= data_in_ff[DATA_WD - 1 - (DATA_BYTE_WD - byte_insert_cnt + j)*8 -: 8] ;
        else if (valid_in && ready_in && last_in == 1'b1 && j >= 0 && j < byte_insert_cnt) 
            data_regs[j] <= data_in_ff[DATA_WD - 1 - (DATA_BYTE_WD - byte_insert_cnt + j)*8 -: 8] ;
        else if (valid_in && ready_in && last_in == 1'b1 && (DATA_BYTE_WD - byte_insert_cnt) >= cnt_1) begin
            if (j >= byte_insert_cnt && j < (byte_insert_cnt + cnt_1))
                data_regs[j] <= data_in[DATA_WD -1 - (j - byte_insert_cnt)*8 -: 8] ;
            else
                data_regs[j] <= 'd0 ;
        end
        else if (valid_in && ready_in && last_in == 1'b1 && (DATA_BYTE_WD - byte_insert_cnt) < cnt_1) begin
            if (j >= byte_insert_cnt && j < DATA_BYTE_WD)
                data_regs[j] <= data_in[DATA_WD -1 - (j - byte_insert_cnt)*8 -: 8] ;
            else if (j >= DATA_BYTE_WD && j < (cnt_1 + byte_insert_cnt))
                data_regs[j] <= data_in_ff[DATA_WD - 1 - (DATA_BYTE_WD - byte_insert_cnt + j)*8 -: 8] ; 
        end
        end
        
            
        
    end 
endgenerate


genvar k;
generate for (k = 0 ; k < 8 ; k = k+1) begin
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n)
           data_reg[k] <= 'd0;
        else
            data_reg[k] <= data_in[DATA_WD -1 -8*k -: 8] ;
        
    end 

    
endgenerate







endmodule